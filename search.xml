<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[websocker]]></title>
    <url>%2F2019%2F07%2F19%2Fwebsocker%2F</url>
    <content type="text"><![CDATA[1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&lt;/dependency&gt; 先导入依赖一个是websocker的启动依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt; 这是对象序列化的依赖 12345public interface WebscoketMapper &#123; List &lt;Equipment_message&gt; websocket(String Mequipment_name);&#125; 这是webscoker的接口，然后通过mybatis.xml书写sql 1234567891011121314&lt;mapper namespace="com.shiyanshi.dashuju.Mapper.WebscoketMapper"&gt; &lt;resultMap id="AllTest" type="com.shiyanshi.dashuju.Pojo.Equipment_message"&gt; &lt;id column="Equipment_Main_id" property="Equipment_Main_id"/&gt; &lt;id column="Monitor_id" property="Monitor_id"/&gt; &lt;id column="Time1" property="Time1"/&gt; &lt;result column="Monitor_name" property="Monitor_name"/&gt; &lt;result column="Mequipment_name" property="Mequipment_name"/&gt; &lt;result column="Vaule" property="Vaule"/&gt; &lt;/resultMap&gt; &lt;select id="websocket" resultMap="AllTest" &gt; select Monitor_name,Vaule from Equipment_message where Mequipment_name =#&#123;Mequipment_name&#125; &lt;/select&gt;&lt;/mapper&gt; namespace对应Mapper这个接口，然后type对应的是实体类的位置，column对应的是数据库的字段，property对应的是实体类的名字，然后通过书写sql来实现mapper接口的功能，为了解耦，书写了seriver与Mapper接口一摸一样 12345public interface WebSocketSeriver &#123; List&lt;Equipment_message&gt; websocket(String Mequipment_name);&#125; 然后通过seriverlmp这个类去实现这个WebSockerSeriver,并重写里面的抽象方法 12345678@Resourceprivate WebscoketMapper webscoketMapper;@Overridepublic List&lt;Equipment_message&gt; websocket(String Mequipment_name) &#123; return webscoketMapper.websocket(Mequipment_name);&#125; 对于websocker 123456789101112@Configuration@ComponentScan("com.shiyanshi.dashuju.config")public class WebSocketConfig &#123; /** * 注入ServerEndpointExporter， * 这个bean会自动注册使用了@ServerEndpoint注解声明的Websocket endpoint */ @Bean public ServerEndpointExporter serverEndpointExporter()&#123; return new ServerEndpointExporter(); &#125; @Configuration代表这是一个配置类，并把这个类交给spring管理，@ComponentScan则是扫描这里面， 12345678910111213141516@Componentpublic class SpringContextHelper extends ServerEndpointConfig.Configurator implements ApplicationContextAware &#123; private static volatile BeanFactory context; @Override public &lt;T&gt; T getEndpointInstance(Class&lt;T&gt; clazz) throws InstantiationException &#123; return context.getBean(clazz); &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; SpringContextHelper.context = applicationContext; &#125;&#125; 这里是为了保证websocker能够像controller一样，类似于自定义配置类，这里就可以解决但注入Mapper接口时它不能执行sql从而爆出空指针的错误。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115@ServerEndpoint(value = "/websocket/&#123;sid&#125;",configurator = SpringContextHelper.class)@Component//创建websocket监听类:WebSocketServerpublic class WebSocketServer &#123; @Resource private Util util ; @Resource private WebSocketPojo webSocketPojo ; //静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。 private static int onlineCount = 0; //concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。 private static CopyOnWriteArraySet&lt;WebSocketServer&gt; webSocketSet = new CopyOnWriteArraySet&lt;WebSocketServer&gt;(); //与某个客户端的连接会话，需要通过它来给客户端发送数据 private Session session; private String an; //接收sid private String sid=""; /** * 连接建立成功调用的方法 * */ @OnOpen public void onOpen(Session session,@PathParam("sid") String sid) throws IOException &#123; this.session = session; webSocketSet.add(this); //加入set中 addOnlineCount(); this.sid=sid; System.out.println("连接成功"); sendMessage("连接成功"); &#125; /** * 连接关闭调用的方法 */ @OnClose public void onClose() &#123; webSocketSet.remove(this); //从set中删除 subOnlineCount(); //在线数减1 &#125; /** * 收到客户端消息后调用的 @OnClose * message客户端发送过来的消息 * */ @OnMessage public void onMessage(String message, Session session) &#123; //群发消息 an=message; for (WebSocketServer item : webSocketSet) &#123; try &#123; System.out.println(an); //System.out.println(webscoketMapper.websocket(an)); List&lt;Equipment_message&gt; websocket= util.websocket(an); String ss = new Gson().toJson(websocket); item.sendMessage(ss);// System.out.println("test");// System.out.println(message);// sendMessage(webscoketMapper.websocket()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @OnError public void onError(Session session, Throwable error) &#123;// log.error("发生错误"); error.printStackTrace(); &#125; /** * 实现服务器主动推送 */ public void sendMessage(String message) throws IOException &#123;// System.out.println("test1");// System.out.println(message); this.session.getBasicRemote().sendText(message); //发送给前端 &#125; /** * 群发自定义消息 * */ public static void sendInfo(String message,@PathParam("sid") String sid) throws IOException &#123; for (WebSocketServer item : webSocketSet) &#123; try &#123; //这里可以设定只推送给这个sid的，为null则全部推送 if(sid==null) &#123; item.sendMessage(message); &#125;else if(item.sid.equals(sid))&#123; item.sendMessage(message); &#125; &#125; catch (IOException e) &#123; continue; &#125; &#125; &#125; public static synchronized int getOnlineCount() &#123; return onlineCount; &#125; public static synchronized void addOnlineCount() &#123; WebSocketServer.onlineCount++; &#125; public static synchronized void subOnlineCount() &#123; WebSocketServer.onlineCount--; &#125;&#125; 这里就是监听类 当服务端和客户端握手成功后，将会成功进入onOpen 12345678public void onOpen(Session session,@PathParam("sid") String sid) throws IOException &#123; this.session = session; webSocketSet.add(this); //加入set中 addOnlineCount(); this.sid=sid; System.out.println("连接成功"); sendMessage("连接成功");&#125; 当执行这一段代码时，将会进入sendMessage这个函数 12345public void sendMessage(String message) throws IOException &#123;// System.out.println("test1");// System.out.println(message); this.session.getBasicRemote().sendText(message); //发送给前端 &#125; 他会向前端传送一个连接成功，之后这个函数执行完，收到客户端消息后调用的 @OnClose message客户端发送过来消息 12345678910111213141516171819 public void onMessage(String message, Session session) &#123; //群发消息 an=message; for (WebSocketServer item : webSocketSet) &#123; try &#123; System.out.println(an); //System.out.println(webscoketMapper.websocket(an)); List&lt;Equipment_message&gt; websocket= util.websocket(an); String ss = new Gson().toJson(websocket); item.sendMessage(ss);// System.out.println("test");// System.out.println(message);// sendMessage(webscoketMapper.websocket()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 用an接受前端发过来的参数，，然后进入增强for，然后把an参数传入接口，通过sql查出的数据封装到websocket这个list集合里面，因为list集合也是一个对象，而sendMessage只能传递字符串类型，所以必须把对象强转成字符串，然后传递给前端。]]></content>
  </entry>
  <entry>
    <title><![CDATA[学习数据库（三）]]></title>
    <url>%2F2019%2F06%2F13%2F%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[排重查询教师所有单位即不重复的depart列 1select distinct depart from teacher 这样出来的结果就不是重复的结果了 查询区间如果查询的东西在一个区间 between 。。。and 。。。。 123select * from score where degree between 60 and 80;或者select * from score where degree &gt;= 60 and &lt;= 80; 查询或者关系的时候假如我们要查询score表中的成绩为85，86或者88的记录，该字段是相同的 1select * from score where degree in(85,86,88); 如果字段不同 1select * from student where class='95031' or ssex='女'; 升序或者降序查询1select * from student order by class desc; //升序是asc，降序是desc 因为一般默认升序 以某个特定字段升序以某个字段降序以con升序，degree 降序 查找 ，在两个进行升序排序是asc必须写 1select * from score order by con asc,degree desc; 统计某个字段的个数这里是统计班级为95031的数目个数 1select count(*) from student where class='95031'； 查询最高分我这里列子查询son，con的最高分 1select son，cno from score where degree=（select max （degree） from score）； 规范的步骤 12select max （degree） from score；select son，cno from score where degree=（select max （degree） from score）； 排序查询最高分假如有同样的最高分，那么这个查询就有点缺陷了 limit 第一个数字表示从多少开始，第二个数字表示查多少条 1select son,cno,degree from score order by degree desc limit 0,1;]]></content>
  </entry>
  <entry>
    <title><![CDATA[学习数据库（二）]]></title>
    <url>%2F2019%2F06%2F12%2F%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[外键约束–班级 12345create table classes(id int primary key,name varchar(20)) –学生表 1234567create table students（id int primary key,name varchar(20),class_id （int）,foreign key(class_id) references classes (id) //该为外键约束，外键就是另外一个表的主键 references 意思就是涉及到classes这个表） 1234567insert into classes value(1,'一班');insert into classes value(2,'二班');insert into classes value(3,'三班');insert into classes value(4,'四班'); 向students插入数据 1234567insert into students value(1001,‘张三’,1);insert into students value(1002,‘张三’,2);insert into students value(1003,‘张三’,3);insert into students value(1004,‘张三’,4); 假如我这样插入时1insert into students value（1005，‘李四’，5）; ![A]L5_$XP~~49RDXT`8Y3302.png](https://i.loli.net/2019/06/12/5d00f3066c28922004.png) 这是因为 5，5代表的是外键，而classes里面没有5所以插入失败 而且当父表被引用的时候是不可以被修改的 所以得出以下结论 –1、主表 （父表）classes中没有的数据值，在副表中，是不可以被使用 –2、主表中的记录被副表引用时，是不可以被删除的 例如 1delete from classes where id=1； ![AK25_$K2U(C~PRAOWCZB`H.png 数据库的三大设计范式–1、第一范式–INF 数据表中的所有字段都是不可分割的原子值？ 123456create table student2(id int primary key,name varchar(20),address varchar(20)); 123insert into value(1,'张三'，'中国四川省成都市武侯区武侯大道100号')；insert into value(2,'李四'，'中国四川省成都市武侯区武侯大道200号')；insert into value(3,'王五'，'中国四川省成都市武侯区武侯大道90号')； –字段值还可以继续拆分，就不满足第一范式 123456789create table student2(id int primary key,name varchar(20),country varchar(30),province varchar(30),city varchar(30),detail varchar (30)); 123insert into value(1,'张三'，'中国','四川省','成都市','武侯区','武侯大道100号')；insert into value(2,'李四'，'中国','四川省','成都市','武侯区','武侯大道200号')；insert into value(3,'王五'，'中国','四川省','成都市','武侯区','武侯大道90号')； ![LN}`4E@GPO8H]_Q]G2K2NTO.png](https://i.loli.net/2019/06/12/5d00f3ecb917653801.png) –范式，设计的越详细，对于某些实际操作可能更好，但不一定都是最好。 第一范式就是拆字段 –2、第二范式–必须是满足第一范式的前提下，第二范式要求，除主键外的每一个列都必须完全依赖于主键。 –如果要出现不完全依赖，只可能在联合主键情况下。 –订单表 12345678create table myorder(product_id int,customer_id int,product_name varchar(20),customer_name varchar(20),primary key(product_id,customer_id)); – 问题 –除主键以外的其他列，只依赖主键的部分字段 –拆表 123456create table myorder(oredr_id int primary key,product_id int,customer_id int); 12345create table product(id int primary key,name varchar(20)); 12345create table customer(id int primary key,name varchar(20)) 产品名字依赖于product里面的主键，而用户名字依赖于customer里面的名字， 而第一个表里面的两个id依赖于myorder的主键，你们会不会联想起外键了？ –分成三个表满足了第二范式 –3、第三范式–3NF –必须满足第二范式，除开主键列的其他列之间不能有传递依赖关系 123456create table myorder(oredr_id int primary key,product_id int,customer_id int，); 123456create table customer(id int primary key,name varchar(20), phone varchar(15) ) ex：数据类型：decimalMySQL DECIMAL数据类型用于在数据库中存储精确的数值。 例如语法 1：column_name DECIMAL(P,D) 其中P表示的是有效数字的位数，D表示是小数的位数，D小于或等于P。 理解可看下面代码： 1234create table decimal_test(id int auto_increment PRIMARY key,score decimal(5,2) -- 取值范围是 **-999.99 到 999.99**); – 整数的位数必须小于等于m-d，不然报错。小数的位数可以大于d位。多出d位时会做四舍五入，截取到d位。– 以上均不包括小数点、符号的位数。数字的总长度是m位，保存后的小数位最多是d位。如果保存后是整数，小数位不会补0。 ex：数据类型：datetime①date类型可用于需要一个日期值而不需要时间部分时； ②datetime类型:可用于需要同时包含日期和时间信息的值。 区别2： ①date：MySQL 以 ‘YYYY-MM-DD’ 格式检索与显示date值； ②datetime:MySQL 以 ‘YYYY-MM-DD HH:mm:ss’格式检索与显示 DATETIME 类型。 – 整数的位数必须小于等于m-d，不然报错。小数的位数可以大于d位。多出d位时会做四舍五入，截取到d位。– 以上均不包括小数点、符号的位数。数字的总长度是m位，保存后的小数位最多是d位。如果保存后是整数，小数位不会补0]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot整合servlet]]></title>
    <url>%2F2019%2F06%2F11%2Fspringboot%E6%95%B4%E5%90%88servlet%2F</url>
    <content type="text"><![CDATA[第一种注册servlet这是pom jar包 创建一个类继承一个接口然后重写doget方法 ![J(4N1[G87IV)M_]5%7WUNE.png urlPatterns=“/first”指的是访问路径 下面在启动类配置 从而整合了servlet。 第二种整合servlet 其他servlet请看https://www.runoob.com/servlet/servlet-intro.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[学习数据库]]></title>
    <url>%2F2019%2F06%2F11%2F%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[学习数据库 因为我已经搭建好了数据库，就不弄了，以后重新搭建的话，再出blog 基本的sql语句 创建数据库 create database 数据库的名字 ; 查看所有数据库 show databases; 使用数据库 use 数据库名字; 查看所有表 show tables; 描述表的结构 desc table 表的名字; 创建表 create table 表的名字（ ID int(11) primary key , name varchar(11), time date(yyyymmdd) ） 上面是创建表，primary key则表明ID为主键，可以通过主键来查询信息，主键不能为空 还有联合主键 primary key（id, name）;则表明id与名字都为主键，当时在数据库添加数据的时候，小伙伴们会惊奇的发现如果我们添加的数据名字一样也可以添加进去，不是说主键唯一吗？联合主键就是id与name不能相同，假如插入了id=1，name=‘李四’，下一个插入了id=2，name=‘李四’，这样是可以插入的，但是如果还是上一条数据插入则不行。 一般来说主键必须包含唯一的值，主键列不能包含NULL值，每个表都有一个主键，并且每个表只能由一个主键，联合主键中任何一个值都不能等于null 不理解也没关系，下一个博客我会专门出一个primary key的 插入语句insert into 表的名字 value（对应的字段）； 我们也可以指定所要插入数据的列： 1INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....) 插入新的行“Persons” 表： LastName FirstName Address City Carter Thomas Changan Street Beijing SQL 语句：1INSERT INTO Persons VALUES ('Gates', 'Bill', 'Xuanwumen 10', 'Beijing') 结果： LastName FirstName Address City Carter Thomas Changan Street Beijing Gates Bill Xuanwumen 10 Beijing 在指定的列中插入数据“Persons” 表： LastName FirstName Address City Carter Thomas Changan Street Beijing Gates Bill Xuanwumen 10 Beijing SQL 语句：1INSERT INTO Persons (LastName, Address) VALUES ('Wilson', 'Champs-Elysees') 结果： LastName FirstName Address City Carter Thomas Changan Street Beijing Gates Bill Xuanwumen 10 Beijing Wilson Champs-Elysees 查询语句select *from 表的名字；（这是查全部的信息） select 列的名称 from 表名称 （查单列） 如需获取名为 “LastName” 和 “FirstName” 的列的内容（从名为 “Persons” 的数据库表），请使用类似这样的 SELECT 语句“ 1SELECT LastName,FirstName FROM Persons “Persons” 表: Id LastName FirstName Address City 1 Adams John Oxford Street London 2 Bush George Fifth Avenue New York 3 Carter Thomas Changan Street Beijing 结果： LastName FirstName Adams John Bush George Carter Thomas 更新语句update 表名称 set 列名称=新值 where 列名称=某值 Update 语句用于修改表中的数据 Person: LastName FirstName Address City Gates Bill Xuanwumen 10 Beijing Wilson Champs-Elysees 我们为 lastname 是 “Wilson” 的人添加 firstname： 1UPDATE Person SET FirstName = 'Fred' WHERE LastName = 'Wilson' 结果： LastName FirstName Address City Gates Bill Xuanwumen 10 Beijing Wilson Fred Champs-Elysees DELETE 语句DELETE 语句用于删除表中的行。 语法1DELETE FROM 表名称 WHERE 列名称 = 值 Person: LastName FirstName Address City Gates Bill Xuanwumen 10 Beijing Wilson Fred Zhongshan 23 Nanjing 删除某行“Fred Wilson” 会被删除： 1DELETE FROM Person WHERE LastName = 'Wilson' 结果: LastName FirstName Address City Gates Bill Xuanwumen 10 Beijing 删除所有行可以在不删除表的情况下删除所有的行。这意味着表的结构、属性和索引都是完整的： 1DELETE FROM table_name 或者： 1DELETE * FROM table_name 修改表结构增加主键约束 1alter table person add primary key（id） 删除主键约束 1alter table person drop primary key； 修改主键约束 1alter table person modify id int primary key ； 如果被unique修饰的话 则不能相同 如果是被unique修饰的联合主键 则两个只要和以前插入的数据不同就行了 删除unique修饰1alter table person drop index name 给字段添加unique1alter table person modify name varchar（20） unique； 非空约束123456789create table user9（id int,name varchar(20) not null）; 默认约束12345678create table user9（id int,name varchar（20），age int defalut 10）; 如果没传入数据，则age默认10，传了值就不会使用默认值]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot-整合mybatis]]></title>
    <url>%2F2019%2F06%2F09%2Fspringboot-%E6%95%B4%E5%90%88mybatis%2F</url>
    <content type="text"><![CDATA[这是我整个框架的包的样子 首先导入依赖 这是mysql连接的依赖 这是mybatis的依赖配置 这是druid数据源的依赖 123456&lt;!-- alibaba的druid数据库连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; 配置好依赖之后我们就是application.properties下配置连接数据库的路径密码端口ip等等 因为我用的是虚拟机的centios当作服务器，在centios搭建了mysql所以就直接用虚拟机的mysql了 接下来就是数据库的配置 12345spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://192.168.52.142:3306/tang?characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=Tk429147451.spring.datasource.type=com.alibaba.druid.pool.DruidDataSource 第一个是mysql的驱动，第二个就是ip地址加端口和数据库表和字符集，第三个就是数据库的名字，下面就是密码，最后一个就是数据源的配置 在application.properties下写 12mybatis.type-aliases-package=com.aiteguigu.springboot06mysql1.pojomybatis.mapper-locations=classpath:mapper/*.xml 表明实体类的位置和mapper.xml的位置 然后接下来我们就来写一个pojo（实体类）名字为User，实体类一定要和数据库的字段一样 12345678910111213141516171819202122232425262728293031public class User &#123; private Integer id; private String name; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 然后在mapper文件夹下创建一个接口Usermapper 123456789@Repositorypublic interface Usermapper &#123; void insertUser(User user); List&lt;User&gt; selectUsersAll(); User selevtUsersById(Integer id); void updateUser(User user); void deleteUserById(Integer id);&#125; 通过mapper.xml的方式来实现这些接口的功能 resultType记得是实体类（pojo）所在包 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.aiteguigu.springboot06mysql1.mapper.Usermapper"&gt; &lt;insert id="insertUser" parameterType="com.aiteguigu.springboot06mysql1.pojo.User"&gt; insert into User (name,age) value(#&#123;name&#125;,#&#123;age&#125;) &lt;/insert&gt;&lt;select id="selectUsersAll" resultType="com.aiteguigu.springboot06mysql1.pojo.User"&gt; select * from User&lt;/select&gt;&lt;select id="selevtUsersById" resultType="com.aiteguigu.springboot06mysql1.pojo.User"&gt;select id,name,age from User where id=#&#123;value&#125;&lt;/select&gt; &lt;update id="updateUser" parameterType="com.aiteguigu.springboot06mysql1.pojo.User"&gt; update User set name=#&#123;name&#125;,age=#&#123;age&#125; where id=#&#123;id&#125; &lt;/update&gt; &lt;delete id="deleteUserById" &gt; delete from User where id=#&#123;value&#125; &lt;/delete&gt;&lt;/mapper&gt; 然后在业务层（service）写一个接口用来处理业务功能UserSerive 12345678910111213public interface UsersService &#123; void addUser(User user); List&lt;User&gt; findUserAll(); User findUserById(Integer id); void updateUser(User user); void deleteUserById(Integer id);&#125; 再在业务层下建立一个文件夹叫做impl来创建一个service类名字叫UsersService，记得一定要写上标签@Service，表示该为业务层，然后自动注入usermapper，重写业务层接口的方法，来实现功能 123456789101112131415161718192021222324252627282930@Service@Transactionalpublic class UsersServiceImpl implements UsersService &#123; @Autowired private Usermapper usermapper; @Override public void addUser(User user) &#123; this.usermapper.insertUser(user); &#125; @Override public List&lt;User&gt; findUserAll() &#123; return this.usermapper.selectUsersAll(); &#125; @Override public User findUserById(Integer id) &#123; return this.usermapper.selevtUsersById(id);&#125; @Override public void updateUser(User user) &#123; this.usermapper.updateUser(user); &#125; @Override public void deleteUserById(Integer id) &#123; this.usermapper.deleteUserById(id); &#125;&#125; 接下来dao层 ，pojo层，serviece层已经全部弄完 接下来就是控制层，我们先创建一个controller的包在下面创建一个Usercontroller的类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Controller@RequestMapping("/users")public class UsersController &#123; @Autowired private UsersService usersService; /** * 页面跳转 * * @param page * @return */ @RequestMapping(value = "/&#123;page&#125;",method = RequestMethod.GET) public String showpage(@PathVariable String page) &#123; return page; &#125; @RequestMapping("/addUser") public String addUser(User user) &#123; this.usersService.addUser(user); return "ok"; &#125;/** * 查询全部用户 */@RequestMapping("/findUserAll") public String findUserAll(Model model)&#123; List&lt;User&gt;list=this.usersService.findUserAll(); model.addAttribute("list",list); return "showUsers";&#125;@RequestMapping("/findUserById") public String findUserById(Integer id,Model model) &#123;User user=this.usersService.findUserById(id);model.addAttribute("user",user);return "updateUser";&#125;@RequestMapping("/editUser") public String editUser(User user)&#123; this.usersService.updateUser(user); return "ok";&#125;@RequestMapping("/delUser") public String delUser(Integer id)&#123; this.usersService.deleteUserById(id); return "redirect:/users/findUserAll";&#125;&#125; return 分别是返回到哪个视图去，因为我们的视图是在templates下，所以我们要导入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 以下就是我各个html的源代码 这个是updateUser.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;添加用户&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action="@&#123;editUser&#125;" method="post"&gt; &lt;input type="hidden" name="id" th:field="$&#123;user.id&#125;"/&gt; 用户姓名：&lt;input type="text" name="name" th:field="$&#123;user.name&#125;"/&gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="age" th:field="$&#123;user.age&#125;"/&gt;&lt;br/&gt; &lt;input type="submit" value="确定"/&gt;&lt;br/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 这是showUsers.html 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;展示用户数据&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border="1" style="width: 500px;"&gt; &lt;tr&gt; &lt;th&gt;用户ID&lt;/th&gt; &lt;th&gt;用户姓名&lt;/th&gt; &lt;th&gt;用户年龄&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="user : $&#123;list&#125;"&gt; &lt;td th:text="$&#123;user.id&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;user.age&#125;"&gt;&lt;/td&gt; &lt;td&gt; &lt;a th:href="@&#123;/users/findUserById(id=$&#123;user.id&#125;)&#125;"&gt;更新用户&lt;/a&gt; &lt;a th:href="@&#123;/users/delUser(id=$&#123;user.id&#125;)&#125;"&gt;删除用户&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 这是ok.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;操作提示页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;操作成功!!!!&lt;/body&gt;&lt;/html&gt; 这是之前的html引用的input.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;添加用户&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action="@&#123;addUser&#125;" method="post"&gt; 用户姓名：&lt;input type="text" name="name"/&gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="age"/&gt;&lt;br/&gt; &lt;input type="submit" value="确定"/&gt;&lt;br/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 接下来就大概全部搭建完了 以下是所有依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.aiteguigu&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-06-mysql1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-06-mysql1&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis的依赖配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.28&lt;/version&gt; &lt;/dependency&gt; &lt;!-- &amp;lt;!&amp;ndash; alibaba的druid数据库连接池 &amp;ndash;&amp;gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.11&lt;/version&gt; &lt;/dependency&gt; &amp;lt;!&amp;ndash;json的相关配置&amp;ndash;&amp;gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-joda&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt; &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt; &lt;/dependency&gt;--&gt; &lt;!-- 分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- alibaba的druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- mybatis generator 自动生成代码插件 --&gt; &lt;!--&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;/plugin&gt;--&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[java基础学习二]]></title>
    <url>%2F2019%2F06%2F06%2Fjava%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[HashMap&lt;Integer,student&gt;map=new HashMap&lt;Integer, student&gt;(); //我定义的键是int类型，值是自定义类Setser=map.keySet(); //先用set中的迭代器存入我得到hashmap中的keyIterator l=ser.iterator(); //注意应为得到的key’是整形最好加个泛型，我在这里郁闷了几天。。while(l.hasNext()) //判断是否有元素{ Integer ab=l.next(); //用int的封装类接受到我的key student a=map.get(ab); //然后用得到的key在map的get里面去得到相对应的value。从而输出 System.out.println(ab+&quot; “+a.name+” &quot;+a.ages）]]></content>
  </entry>
  <entry>
    <title><![CDATA[java基础学习]]></title>
    <url>%2F2019%2F06%2F06%2Fjava%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[-final所定义的类，不能被继承但是可以继承其他类，对于final定义的类不能被重写，而且，final的变量名，当在创建对象的之前可以进行赋值修改，但是在创建对象之后是不能进行修改，而且修改只能一次。-static 所申明的，可以视为c语言的全局变量，对于其他类而言不需要创建对象，不需要通过点来访问成员变量或者是方法，而且用staitc所申明的变量，在运用其他类进行赋值的时候，他们共享数据区，如果改了一次，第二个变量输出的这个值还是第一次改变的这个值，而对于staitic的用法，你看你所定义的方法是否都是静态，只要都是静态变量则可以用static，若不是则不用。-对于public static final double 类似于宏定义，不会被改变。-而对于内部类可以被继承类和接口，对于内部类用外部类的变量名和方法可以直接调用，不管是private什么权限都可以使用，而对于外部类使用内部类则需要点调用，基本规则是内部类.外部类 加变量名=new 内部类.new.外部类。-匿名对象只能用一次，且不在堆内存进行分配内存。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F06%2F%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
